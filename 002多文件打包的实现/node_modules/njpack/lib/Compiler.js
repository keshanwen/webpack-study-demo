const fs = require("fs");
const ejs = require("ejs");
const path = require("path");
const parser = require("@babel/parser");
const traverse =  require("@babel/traverse").default;
const generate = require('@babel/generator').default;
const t = require('@babel/types');

class Compiler {
    constructor(config) {
        //1.保存配置文件（webpack.config.js）
        this.config = config;
        //2.保存自调用函数的参数（保存入口模块 + 模块依赖）
        this.modules = {};
    }

    //1.开始编译
    run() {
        //首次传递进去的路径是主模块路径,然后依次找到主模块的所有依赖
        this.buildModule(this.config.entry);
        //webpack进行打包
        this.emitFile();
    }

    buildModule(modulePath) {
        //1.读取入口文件中的内容
        let code = this.getSource(modulePath);
        //2,修改当前模块的代码
        let {resultCode, dependencies} = this.parseModule(code);
        //3,将主模块的路径和代码保存到modules中
        this.modules[modulePath] = resultCode;
        // 4,处理依赖模块，将依赖模块的路径和代码也保存到module中
        // 递归处理，要好好理解
        dependencies.forEach((dePath) => {
            this.buildModule(dePath);
        })
    }

    parseModule(code){
        // 1.将当前模块的代码转换成抽象语法树
        let ast = parser.parse(code);
        // 定义变量保存主模块地址
        let rootPath = path.dirname(this.config.entry);
        // 定义数组保存当前模块所有的依赖
        let dependencies = [];
        // 2.修改抽象语法树中的内容
        traverse(ast, {
            CallExpression(nodePath){
                let node = nodePath.node;
                if(node.callee.name === "require"){
                    // 2.1将require修改为__webpack_require__
                    node.callee.name = "__webpack_require__";
                    // 2.2修改require导入的路径
                    let modulePath = node.arguments[0].value;
                    modulePath = ".\\" +path.join(rootPath, modulePath);
                    modulePath = modulePath.replace(/\\/g, "/");
                    dependencies.push(modulePath);
                    node.arguments = [t.StringLiteral(modulePath)];
                }
            }
        });
        // 3.将修改之后的抽象语法树转换成代码
        let resultCode = generate(ast).code;
        // 4.返回结果
        return {resultCode, dependencies};
    }


    //获取模块内容
    getSource(modulePath) {
        let content = fs.readFileSync(modulePath, "utf8");
        return content;
    }

    //webpack进行打包
    emitFile() {
        //1.读取ejs模板
        let templatePath = path.resolve(__dirname, "main.ejs");
        let template = fs.readFileSync(templatePath, "utf8");
        //2.利用变量替换模板中的内容
        let resultCode = ejs.render(template, {entryId: this.config.entry, modules: this.modules});
         //把改造后的代码写入到打包后的文件中去
        //3.将最终的代码写入到打包后的文件中
        //3.1获取输出的目录
        let outputDir = this.config.output.path;
        // //3.2判断目录是否存在
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir);
        }
        // //3.3获取指定文件或者文件路径
        let outputPath = path.resolve(outputDir, this.config.output.filename);
        fs.writeFileSync(outputPath, resultCode);
    }
}

module.exports = Compiler;









